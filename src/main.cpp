#include "xyce_wrapper.h"
#include <iostream>
#include <memory>
#include <cmath>

// Include Verilated model header
// This file is generated by Verilator
#include "Vcounter.h"
#include "verilated.h"

// Simulation parameters
const int MAX_CYCLES = 100;
const double V_REF = 12.0; // Reference voltage for DAC
const double B_WIDTH = 16;

int main(int argc, char **argv) {
  // Initialize Verilator
  Verilated::commandArgs(argc, argv);

  // Create Digital Model instance
  auto top = std::make_unique<Vcounter>();

  // Create Analog Wrapper instance
  // Assuming the template is in analog/template.cir relative to the project
  // root And we run from the project root
  XyceWrapper analog("analog/template.cir", ".");

  // Initialize signals
  top->clk = 0;
  top->rst_n = 0;
  top->enable = 0;

  // Initial analog state
  double cap_voltage = 0.0;

  std::cout << "Starting Hybrid Simulation..." << std::endl;
  std::cout << "Cycle\tDigital(Count)\tDAC(V)\tAnalog(CapV)" << std::endl;

  // Reset sequence
  for (int i = 0; i < 5; ++i) {
    top->rst_n = 0;
    top->clk = !top->clk;
    top->eval();
  }
  top->rst_n = 1;
  top->enable = 1;

  // Main Loop
  for (int cycle = 0; cycle < MAX_CYCLES; ++cycle) {
    // 1. Digital Step (Clock High)
    top->clk = 1;
    top->eval();

    // 2. Read Digital Output
    int digital_out = top->count;

    double dac_voltage = (digital_out / (std::pow(2.0, B_WIDTH) - 1.0)) * V_REF;

    // 4. Analog Step
    // Run Xyce for one timestep with the new input voltage
    // and the previous capacitor voltage as initial condition
    double next_cap_voltage = analog.run_step(dac_voltage, cap_voltage);

    // 5. Update Analog State
    cap_voltage = next_cap_voltage;

    // 6. Digital Step (Clock Low)
    top->clk = 0;
    top->eval();

    // Log
    std::cout << cycle << "\t" << digital_out << "\t" << dac_voltage << "\t"
              << cap_voltage << std::endl;

    if (Verilated::gotFinish())
      break;
  }

  std::cout << "Simulation Finished." << std::endl;

  return 0;
}
